# 八、线程池的使用
## 1.在任务与执行策略间的隐性耦合
- 依赖性任务
- 使用线程封闭的任务
- 对响应时间敏感的任务
- 使用ThreadLocal的任务
只有当任务都是同类型且相互独立时，线程池的性能才能达到最佳。

1.1线程饥饿死锁
在线程池中如果任务依赖于其他任务，那么可能产生死锁。
1.2运行时间较长的任务
## 2.设置线程池的大小
线程池的理想大小取决于提交任务的类型和所部署系统的特性。
给出下列定义：
N = CPU处理器数量
U = CPU使用率。 0<U<1
W = 任务等待时间
C = 任务计算时间
要使处理器到达期望的效率，线程池的最优大小等于：
SIZE = N * U * （1 + W/C）
## 3.配置ThreadPoolExecutor
3.1线程的创建与销毁。线程池大小
3.2管理队列任务
3.3饱和策略
 - AbortPolicy。默认策略，该策略会抛出RejectedExecutionException。
 - CallerRunsPolicy。将任务交由调用者线程自己执行。
 - DiscardPolicy。悄悄抛弃任务。
 - DiscardOldestPolicy。抛弃下一个被执行的任务，如果工作队列是一个优先级队列，那么将抛弃优先级最高的任务。
 3.4线程工厂
 可以指定一个线程工厂方法，定制线程池的配置信息
 3.5在调用构造函数后再定制ThreadPoolExecutor
 使用unconfigurableExecutorService来包装线程池，以确保执行策略不会被修改
 ## 4.扩展ThreadPoolExecutor
 - beforeExecute
 - afterExecute
 - terminated
 ## 5.递归算法的并行化
 ## 小结
 对于并发执行的任务，Executor是一种强大且灵活的框架，它提供了大量可调节的选项，比如创建线程和关闭线程的策略，处理队列任务的策略，处理过多任务的策略，并提供了几个钩子方法来扩展它的行为。然而，与大多数功能强大的框架一样，其中有些设置参数并不能很好地工作，某些类型的任务需要特定的执行策略，而一些参数组合则可能产生奇怪的结果。

 # 十、避免活跃性危险
 ## 1.死锁
 当一个线程永远地持有一个锁，并且其他线程都在试图获取这个锁时，那么它们将永远被阻塞。在JVM中，当一组线程发生死锁时，这些线程就永远不能使用了，恢复应用程序的唯一方法就是中止并重启它。
 1）锁顺序死锁
 两个线程试图以不同的顺序获取相同的锁。
 如果所有线程以固定的顺序来获取锁，那么在程序中就不会出现锁顺序死锁问题。
 2）动态的锁顺序死锁
 3）在协作对象之间发生的死锁
 如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁（这可能产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。
 4）开放调用
 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。
 在程序中应尽量使用开放调用，与那些在持有锁时调用外部方法的程序比相比，更易于对依赖开放调用的程序进行死锁分析。
 5）资源死锁
 当多个线程在同一个资源集合上等待时，同样会发生死锁。
 如持有不同数据库的连接时。
 另一种基于资源的死锁形式就是线程饥饿死锁（Thread-Starvation Deadlock），在有界线程池/资源池中执行相互依赖的任务会导致线程饥饿死锁。
 ## 2.死锁的避免与诊断
 - 如果一个程序每次至多获取一个锁，那么不会有死锁问题
 - 如果要获取多个锁，那么在设计时必须考虑锁的顺序，：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。
 1）支持定时的锁
 显式地使用Lock类中的定时tryLock功能。当使用内置锁时，只要没有获得锁，就会永远等待下去，而显式锁可以指定一个超时时限，在等待超过该时间后tryLock会返回一个错误信息。
 2）通过线程转储信息来分析死锁
触发线程转储操作：
- UNIX。向JVM进程发送SIGQUIT信号（kill -3）或按下Ctrl+\
- Windows。按下Ctrl-Break
## 3.其他活跃性危险
1）饥饿
当线程由于无法访问它需要的资源而不能继续执行时，就发生了饥饿（Starvation）。
引发饥饿的最常见资源就是CPU时钟周期。如果在Java应用程序中对线程优先级使用不当，或者在持有锁时执行一些无法结束的结构，那么也可能导致饥饿。
要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题，在大多数并发应用程序中，都可以使用默认的线程优先级。
2）糟糕的响应性
GUI程序中使用了后台线程，CPU密集型的后台任务可能对响应性造成影响。
3）活锁
活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作。
## 小结
活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了中止应用程序外没有其他机制可以帮助从这种故障时恢复过来。最常见的活跃性问题就是锁顺序死锁，在设计时应尽量避免产生锁顺序死锁：确保线程在获取多个锁时保持一致的顺序。最好的解决办法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。
# 十一、性能与可伸缩性
## 1.对性能的思考
提升性能意味着用更少的资源做更多的事情。使用多线程的目的是为了提升性能，但多线程同样也引入了额外开销，如果过度地使用线程，那么带来的开销可能会超过带来的性能提升。
1）性能与可伸缩性
- 性能：时间指标，表示某个指定的任务“多快”能处理完；数量指标，表示计算资源一定的情况下能完成“多少”任务。
- 可伸缩性：当增加计算资源时，程序的吞吐量或处理能力相应增加
2）评估各种性能权衡因素
- 避免不成熟的优化，首先保证程序的正确性，再提升运行速度
- 一定要有明确的性能需求，以测试为基准，不要猜测
## 2.Amdahl定律
在增加计算资源的情况下，程序理论上所能实现的最高加速比，这个值取决于程序中可并行组件和串行组件所占的比重。假定F为必须串行执行的部分，根据Amdahl定律，在包含N个处理器的机器中，最高加速比为：
SpeedUp <= 1/(F+(1-F)/N)
## 3.线程引入的开销
1）上下文切换
在大多数通用处理器中，上下文切换的开销相当于5000-10000个时钟周期，也就是几微秒。使用vmstat等监控工具可以查看上下文切换次数及在内核中执行时间占比，如果超过10%，那么表示调度活动发生得很频繁
2）内存同步
- 内存栅栏（Memory Barrier），刷新缓存，使缓存无效，抑制JVM优化，在内存栅栏中，大多数操作不能被重排序。
- 非竞争的同步。a.快速通道（fast-path）开销很小，约20-250个时钟周期；b.JVM锁消除优化(逸出分析)
3）阻塞
JVM在实现阻塞行为时，有两种方式：
- 自旋等待，通过循环不断尝试获取锁，直到成功
- 挂起，通过操作系统挂起被阻塞的线程
这两种方式的效率高低要取决于上下文切换的开销以及成功获取锁前等待的时间。
## 4.减少锁的竞争
有三种方式能可以降低锁的竞争程度：
- 减少锁的持有时间；
- 降低锁的请求频率；
- 使用带协调机制的独占锁，这些机制允许更高的并发性。
1）缩小锁的范围（快进快出）
减少锁的持有时间
2）减小锁的粒度
通过锁分解、锁分段技术来降低锁的请求频率
3）锁分段
将锁分解技术进一步扩展为对一组独立对象上的锁进行分解。锁分段的一个劣势是：与采用单个锁实现独占访问相比，要获取多个锁来实现独占访问将更加困难且开销更高。
4）避免热点域
当每个操作都请求多个变量时，锁的粒度很难降低，这是性能与可伸缩性之间相互制衡的一个方面，常见的优化措施是将需要反复计算的结果缓存起来，将会引入一些“热点域（Hot Field）”，而这些热点域往往会限制伸缩性。
5）一些替代独占锁的方法
放弃使用独占锁，使用一种友好并发的方式来管理共享状态。
- 并发容器
- 读-写锁
- 不可变对象
- 原子变量
6）检测CPU的利用率
监测工具
UNIX
- vmstat
- mpstat
WINDOWS
- perfmon
如果CPU没有得到充分利用，通常有以下几种原因：
- 负载不充分
- I/O密集
- 外部限制
- 锁竞争
7）向对象池说“不”
通常，对象分配的开销比同步的开销更低。
## 5.减少上下文切换的开销
## 小结
由于使用线程是为了充分利用多处理器的计算能力，因此在并发程序的性能讨论中，通常更多地将侧重点放在吞吐量和可伸缩性上，而不是服务时间。Amdahl定律告诉我们，程序可伸缩性取决于在所有代码中必须被串行执行的代码所占的比例。因为Java程序中串行操作的主要来源是独占方式的资源锁，因此通常可以通过以下方式提升可伸缩性：减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。
# 十二、并发程序的测试
并发测试大致分为两类：
- 安全性测试（不发生任何错误的行为）
- 活跃性测试（某个良好的行为终会发生）
与活跃性测试相关的是性能测试，衡量指标有：
- 吞吐量
- 响应性
- 可伸缩性
## 1.正确性测试
1)基本的单元测试
2)对阻塞操作的测试
3)安全性测试
4)资源管理的测试
5)使用回调
6)产生更多的交替操作
## 2.性能测试
1)多种算法比较：ArrayBlockingQueue和LinkedBlockingQueue（并发性更好，因为其take、put操作竞争更小）
2)响应性衡量:除非线程因为密集的同步需求而被持续地阻塞，通常来说非公平的信号量能实现更好的吞吐量，而公平的信号量则能实现更低的变动性，应该根据具体需求决定使用何种信号量（Semaphore）
## 3.避免性能测试的陷阱
1)垃圾回收
2)动态编译
3)对代码路径的不真实采样
4)不真实的竞争程度
5)无用代码的消除
## 4.其他的测试方法
1)代码审查
2)静态分析工具
3)面向切面的测试技术
4)分析与监测工具
## 小结
要测试并发程序的正确性可能非常困难，因为并发程序的很多故障模式都是一些低概率事件，它们对于执行时序、负载情况以及其他难以重现的情况都非常敏感。而且在测试程序中还会引入额外的同步或执行时序限制，这些因素将掩盖被测试代码中的一些并发问题。要测试并发程序的性能同样非常困难，与使用静态编译语言编写的程序相比，Java编写的程序测试起来更加困难，因为动态编译、垃圾回收及自动优化等操作都会影响与时间相关的测试结果。










